Селекторы - выборщик

State должен хранить данные так, как удобно ему
То есть он не должен знать про ui


И вот бывают ситуации когда во многие компоненты мы передаём одинаковые данные из state 
И вот чтобы было проще работать, проще сделать получение данные из state в самом бизнесе, то есть 
Вынести в отдельную функцию:

Во-первых: легко менять название в этих функциях
Во-вторых: не надо лезть в ui
В-третьих: при изменении state, легко и изменить эту функцию

И вот эти функции называются селекторы 

И вот так это всё работает: 

export const getUsers = (state) => {
	return state.users
}

после там где нужно импортируем и засовываем в mapStateToProps


const mapStateToProps = (state) => {
	return {
		users: getUsers(state)
	}
}

И само определение

селектор это функция которая принимает state и возвращает его нужную часть

(lesson 82)
mapStateToProps срабатывает каждый раз когда в state что-то меняется

Из-за этого есть проблемы:

1. Даже если что-то в state поменялось, что не имеет значения для profile, то mapStateToProps всё равно вызовется
2. Сложно дебажить
3. Если у нас более сложный селектор, то в нем может быть метод filter
а мы знаем, что метод filter в памяти создает еще один массив, и вот это еще большая проблема

и тут нам поможет библиотека reselect

и по факту когда либо функция вызывается, она должна где-то у себя сохранять то, что вернула
чтобы сравнить это в следующий раз и если ничего не поменялось то просто берем тот предыдущий результат

но мы не хотим получать предыдущий результат, мы хотим актуальный, то есть по сути мы должны указать 
при каком условии нам нужно вызывать функцию

и нам поможет reselect

И как он работает:

Если у нас сложный селектор то нужно создать его с помощью библиотеки reselect

И вот есть допустим у нас сложный select 

export const getUsers = (state) => {
	return state.users.filter(u => true)
}


и вот так это будет с помощью reselect

const getUsers = (state) => {
	return state.users
}

export const getUsersSuper = createSelector(getUsers, (state) => {
	return state
})


И про createSelector, сначала мы передаём зависимости, оттуда берётся state.users после 
мы return state


И вот теперь у нас mapStateToProps будет тоже также постоянно отправляться, но библиотека будет следить, 
надо ли передавать новые данные, и в зависимости от этого будет render

Также допустим вот еще пример:

Где мы возвращаем одно свойство
const getIsAuth = (state) => {
	return state.auth.isAuth
}


export const getIsAuthSuper = createSelector(getIsAuth, (isAuth) => {
	return isAuth
})

и еще пример:

const getIsAuth = (state) => {
	return state.auth.isAuth
}
const isFetching = (state) => {
	return state.auth.isFetching
}

export const getIsAuthSuper = createSelector(getIsAuth, isFetching, (isAuth, isFetching) => {
	return isAuth
})
То есть для каждой зависимости своя переменная

Селекторы - маленькие функции которые получают state и получают из него данные
Реселектор - уже делает логику с селекторами