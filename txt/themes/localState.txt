Local State 

Вот мы пишем код, и не думаем, где же он будет сохраняться

И например при клике на статус, выпадает поле ввода, для изменения этого статуса, как бы мы это сделали

Хранили бы допустим в state какой либо editMode и если false, то поля ввода нету, или есть


Но лучше использовать локальный state, то есть для самой компоненты отдельный state, и компонента, будет перерисовываться если
Этот локальный state изменится

И для этого мы будем использовать классовую компоненту, т.к. React для классовой компоненты создаёт объект и сохраняет его в памяти
И просто тыкает допустим на метод render, и поэтому у классовой компоненты должен храниться state

Еще раз, то есть зачем нам нужно хранить штуку, которая как бы открывает ui в бизнесе, если можем хранить прямо возле ui


и вот пример

class ProfileStatus extends React.Component {
	state = {
		editMode: false,
	}
	setActiveEditMode = () => {
		this.state.editMode = true
	}
	render() {
		return (
			<>
				<h2 className="profile-status__title">Status</h2>
				{
					this.state.editMode == false ? <div>
						<button onClick={e => {
							this.setActiveEditMode()
							e.preventDefault()
						}} className="profile-status__button _btn">
							{this.props.status}
						</button>
					</div> :
						<div>
							<input type="text" className="profile-status__input _input" value={this.props.status} />
						</div>
				}
			</>
		)
	}
}

Но как перерисовать этот локальный state?

можно использовать метод forceUpdate()

Но лучше его избегать (можно сказать что forceUpdate это костыль), поэтому надо использовать setState

this.setState( { editMode: true } )
И он сам импортируется из класса React.Component и законнектится с локальным state

И важно еще понимать что он асинхронен, то есть вот пример:


console.log('Yo')

this.setState( { editMode: true } )

console.log('Yo')


И setState выполнится после двух console.log()
Ну и перерисует state


и сейчас наш editMode меняется в localState но наш status приходит из глобального state, и поэтому компонента по сути будет
перерисовываться только саму себя, а global state не будет, поэтому в localState надо тоже добавить status, который будет как раз приходить из пропсов

Также мы это сделали чтобы flux круговорот не дёргал global state а дергал localState, потому что это очень разгружает реакт
т.к. мы при onChange на инпуте, не кидаем данные в state и не кидаем в ui, а вот в нашем случае это необходимо, т.к. оптимизация
И потом мы будем отправлять put запрос на сервак, чтобы обновить статус, а если будем всегда делать localState для хранения любого текста
инпута, то так плохо, т.к. данные с инпута хранятся в localState, а не в global state


и то есть данные должны в global state приходить  с сервака, а потом уже к localState


мы не можем делать flux круговорот через global state, т.к. бизнес должен отправить запрос на сервак, он там всё подтвердит,а потом
уже global state отправит свои данные полученные с сервера в ui и ui в локальном state будет сам крутить свой flux до тех пор, пока
пользователь не уберет фокус с поля, и как только это случится, то отправится запрос на сервер, и обновится статус, а потом опять 
бизнес запросит данные с сервера, и так по кругу

То есть нам не надо каждый раз при нажатии на букву кидать запрос на сервер


то есть локальные данные, это данные которые не сильно уж и имеют значение,в нашем случае пока мы вводим в инпут буквы
Они хранятся в localState и они не будут такими важными, пока их не отправим в бизнес который уже обратится к API 


то есть у нас есть editMode и зачем бизнесу знать,в каком он состоянии, вот оно основное предназначение localState

еще плюс localState что при вводе инпута, мы не делаем полноценный flux круговорот и поэтому пропсы приходят только после обновления
сервера, и поэтому метод componentDidUpdate прямо как раз, если бы было так,что мы бы вводили  через global state то 
prevProps всегда бы был НЕ РАВЕН this.props и поэтому был бы бесконечный цикл