Axios простой пример


Допустим у нас есть сервер, на котором есть данные

И чтобы их получить, мы можем использовать маленькую удобную библиотеку axios
Почему axios а не fetch

Во-первых: axios проще, и удобнее и вроде как быстрее
Во-вторых: fetch устарел
В-третьих: axios автоматически переводит в json (JSON.stringify)


Как же пользоваться, например у нас есть сервер на котором данные

Вот его url: 'https://localhost:5000/'
И на нём есть данные 'https://localhost:5000/users'

И вот оттуда мы можем взять users

let response = axios.get('https://localhost:5000/users')

return response.data

Но нам нужно return только тогда, когда response придёт
поэтому нужно использовать либо промисы, либо async

async:

const getData = async () => {
	let response = await axios.get('https://localhost:5000/users')
	// Ждем пока придёт response
	return response.data
}

promise: 


axios.get('https://localhost:5000/users').then(response => {
	return response.data
})


get запросы:
Основные:
page
count

И эти get запросы используются в pagination
Постраничном выводе данных в нашем случае пользователей

Допустим у нас 20 пользователей и мы хотим поделить их на каждую страницу и чтоб на каждой странице было по 4 пользователя

Посчитаем  колво страниц
20 / 4 = 5

5 страниц

Но на нашем примере пусть будет по 1 на странице и того 3 / 1 = 3

3 страницы 

для этого нужно поменять немного ajax запрос


axios.get(`http://localhost:3000/users?page=${this.props.currentPage}&count=${this.props.pageSize}`)

Как же делаются get запросы
Сначала ставим ? потом page, это какую страницу вывести, в нашем случае currentPage потом 
count это сколько на странице вывести контента


Также в axios можно передавать параметры


пример:

axios.get("url", {withCredentials: true})

withCredentials означает что мы по умолчанию будем закидывать куку в запрос


Так вот, а в методе post параметры перекидываются 3 параметром:


axios.post("url", null, {withCredentials: true})

Также во избежании ошибок в методах post delete
должен быть API-KEY который мы можем взять на нашей апишке

А теперь отдельно про withCredentials

Разберём пример с follow unfollow

Если мы будем на кого либо подписываться без withCredentials, то запрос на сервак пойдёт по сути как от анонима

а если мы withCredentials поставим на true, то он автоматически кинет и нашу куку, с login email...
То есть уже не от анонима

также чтобы работало follow unfollow, напомню мы же еще и users получаем с сервака, а там тоже от анонима, и ведь с сервака данные такие , что у некоторых стоит
followed false, и когда мы подпишемся, то при обновлении страницы, данные останутся такие, которые мы получаем с сервака, а не с нашего профиля, в котором
эти данные уже изменены

И вот можно заметить, что мы постоянно пишем практически на один и тот же url разные запросы, это можно упростить

Но преждевременно поговорим, зачем это

1. Дублирование кода - плохо
2. Мы должны в ui просто как с dispatch передавать данные в store только здесь не store

А сам этот метод называется - DAL (data access layer)


Мы создадим отдельный файл - api.js  в котором будем писать наши запросы

вот пример:

export const getUsers = (pageNumber = 1, pageSize) => {
	return axios.get(`https://social-network.samuraijs.com/api/1.0/users?page=${pageNumber}&count=${pageSize}`,
		{ withCredentials: true })
}	

и вот таких запросов с одинаковым url в нашем случае - https://social-network.samuraijs.com/api/1.0/
Может быть много, и лучше сделать так называемый creator или же instanse


const instanse = axios.create({
	baseURL: "https://social-network.samuraijs.com/api/1.0/"
	// И в него мы засовываем базовый url или же url, который будет повторяться

	// И также можно засунуть настройки которые будут повторяться
})

И как же пользоваться:

Просто обращаемся к creator'у и пишем запрос (get/post/delete/options/patch)

а далее путь, который будет после baseURL
instanse.get("/users").then(response => {
	return response
})
Также, не обязательно сразу делать then, т.к суть DAL в том, что UI не должен обращаться к серверу



Также забыл упомянуть о методе options 
Он как бы проверка, перед тем как отправить основной запрос (get/post ... )
Он кидает проверочный - options
Чтобы политика cors сказала - да , ошибок нет, кидайте основной запрос


